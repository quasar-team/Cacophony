{# Author: Piotr Nikiel, <piotr@nikiel.info> #}
{# Date: Feb 2019, original version in XSLT  #}
{#       May 2020, rework to Jinja2          #}

// generated using Cacophony, an optional module of quasar, see: https://github.com/quasar-team/Cacophony

{% macro cache_variable_address_space_write_to_mode(aswrite) %}
  {% if aswrite == 'forbidden' %}DPATTR_ADDR_MODE_INPUT_SPONT /* mode */
  {%- else %} DPATTR_ADDR_MODE_IO_SPONT /* mode */
  {%- endif %}
{% endmacro %}

{% macro source_variable_address_space_mode_to_mode (asread, aswrite) %}
  {% if asread != 'forbidden' and aswrite != 'forbidden' %}DPATTR_ADDR_MODE_IO_SQUERY
  {%- elif asread != 'forbidden' and aswrite == 'forbidden' %}DPATTR_ADDR_MODE_INPUT_SQUERY
  {%- elif asread == 'forbidden' and aswrite != 'forbidden' %}DPATTR_ADDR_MODE_OUTPUT_SINGLE
  {%- else %}
    {{debug("ERROR: settings of this source-variable don't make much sense")}}
  error('Don't know how to map this address because it support neither read nor write...');
  {% endif %}
{% endmacro %}

const string CONNECTIONSETTING_KEY_DRIVER_NUMBER = "DRIVER_NUMBER";
const string CONNECTIONSETTING_KEY_SERVER_NAME = "SERVER_NAME";
const string CONNECTIONSETTING_KEY_SUBSCRIPTION_NAME = "SUBSCRIPTION_NAME";

bool {{functionPrefix}}dpTypeExists(string dpt)
{
  dyn_string queriedTypes = dpTypes(dpt);
  return (dynlen(queriedTypes) >= 1);
}

bool {{functionPrefix}}addressConfigWrapper (
  string  dpe,
  string  address,
  int     mode,
  mapping connectionSettings,
  bool active=true
)
{
  string subscription = "";
  if (mode != DPATTR_ADDR_MODE_IO_SQUERY && mode != DPATTR_ADDR_MODE_INPUT_SQUERY)
  {
    subscription = connectionSettings[CONNECTIONSETTING_KEY_SUBSCRIPTION_NAME];
  }
  dyn_string dsExceptionInfo;
  fwPeriphAddress_setOPCUA (
    dpe /*dpe*/,
    connectionSettings[CONNECTIONSETTING_KEY_SERVER_NAME],
    connectionSettings[CONNECTIONSETTING_KEY_DRIVER_NUMBER],
    "ns=2;s="+address,
    subscription /* subscription*/,
    1 /* kind */,
    1 /* variant */,
    750 /* datatype */,
    mode,
    "" /*poll group */,
    dsExceptionInfo
    );
  if (dynlen(dsExceptionInfo)>0)
    return false;
  DebugTN("Setting active on dpe: "+dpe+" to "+active);
  dpSetWait(dpe + ":_address.._active", active);

  return true;
}

bool {{functionPrefix}}evaluateActive(
  mapping addressActiveControl,
  string className,
  string varName,
  string dpe)
{
  bool active = false;
  if (mappingHasKey(addressActiveControl, className))
  {
    string regex = addressActiveControl[className];
    int regexMatchResult = regexpIndex(regex, varName, makeMapping("caseSensitive", true));
    DebugTN("The result of evaluating regex: '"+regex+"' with string: '"+varName+" was: "+regexMatchResult);
    if (regexMatchResult>=0)
      active = true;
    else
    {
      active = false;
      DebugN("Note: the address on dpe: "+dpe+" will be non-active because such instructions were passed in the addressActive mapping.");
    }
  }
  else
    active = true; // by default
  return active;
}

{% for class_name in designInspector.get_names_of_all_classes() %}
{% set cls = designInspector.objectify_class(class_name) %}

bool {{functionPrefix}}configure{{class_name}} (
  int     docNum,
  int     childNode,
  string  prefix,
  bool    createDps,
  bool    assignAddresses,
  bool    continueOnError,
  mapping addressActiveControl,
  mapping connectionSettings)
{
  DebugTN("Configure.{{class_name}} called");
  string name;
  if(xmlGetElementAttribute(docNum, childNode, "name", name) != 0)
  {
    {% if designInspector.is_class_always_singleton(class_name, instantiated_by_filter='configuration')
      and designInspector.get_class_default_instance_name(class_name) != None %}
      {% set instance_name = designInspector.get_class_default_instance_name(class_name) %}
      DebugTN("Configure.{{class_name}} singleton instance configuration has no attribute [name], defaulting to class name [{{instance_name}}]");
      name = "{{instance_name}}";
    {% else %}
      DebugTN("Configure.{{class_name}} instance configuration has no attribute [name]: invalid configuration, returning FALSE");
      return false;
    {% endif %}
  }

  string fullName = prefix+name;
  bool success = {{functionPrefix}}configureFromName{{class_name}}(name, prefix, createDps, assignAddresses, continueOnError, addressActiveControl, connectionSettings);

  {# Only generate CV profile handling code for classes that actually have CVs #}
  {% set cv_profiles = (configInspector.get_cv_profiles_for_class(class_name) if configInspector else {}) %}
  {% if cv_profiles %}
  // This class has {{cv_profiles|length}} CV profile(s)
  dyn_int cvChildren = {{functionPrefix}}getChildNodesWithName(docNum, childNode, "CalculatedVariable");

  if (dynlen(cvChildren) > 0)
  {
    // Collect all CV names for this instance to determine profile
    dyn_string cvNames;
    for (int i=1; i<=dynlen(cvChildren); i++)
    {
      string cvName;
      if(xmlGetElementAttribute(docNum, cvChildren[i], "name", cvName) == 0)
      {
        dynAppend(cvNames, cvName);
      }
    }
    DebugTN("Collected CV names for this instance are:" + cvNames);
    // Sort CV names to match profile detection logic
    dynSortAsc(cvNames);

    // Find matching CV profile DPT by checking structure
    string profileId = "";

    for (int profileNum = 1; profileNum <= {{cv_profiles|length}}; profileNum++)
    {
      string testDpt = "{{typePrefix}}{{class_name}}_CV" + profileNum;

      // Check if this DPT has the same DPEs as our CV list
      dyn_dyn_string elements;
      dyn_dyn_int types;
      dpTypeGet(testDpt, elements, types);
      dyn_string dpeNames;

      DebugTN("DEBUG: Checking profile " + testDpt + ", dpTypeGet returned " + dynlen(elements) + " elements");

      for (int j=2; j<=dynlen(elements); j++)  // Start from 2 to skip the DPT name itself
      {
        if (dynlen(elements[j]) >= 2)
        {
          string dpeName = elements[j][2];  // Second item in each row is the DPE name
          DebugTN("DEBUG:   Element " + j + ": DPE name: '" + dpeName + "'");
          if (dpeName != "")
            dynAppend(dpeNames, dpeName);
        }
      }

      dynSortAsc(dpeNames);

      DebugTN("DEBUG: After sorting, dpeNames has " + dynlen(dpeNames) + " items: " + strjoin(dpeNames, ", "));
      DebugTN("DEBUG: Expected cvNames has " + dynlen(cvNames) + " items: " + strjoin(cvNames, ", "));

      // Compare sorted DPE names with sorted CV names
      if (dynlen(dpeNames) == dynlen(cvNames))
      {
        bool match = true;
        for (int k=1; k<=dynlen(cvNames); k++)
        {
          if (cvNames[k] != dpeNames[k])
          {
            DebugTN("DEBUG: Mismatch at position " + k + ": '" + cvNames[k] + "' != '" + dpeNames[k] + "'");
            match = false;
            break;
          }
        }

        if (match)
        {
          DebugTN("DEBUG: MATCH FOUND! Using profile " + profileNum);
          profileId = (string)profileNum;
          break;
        }
      }
    }

    if (profileId == "")
    {
      DebugTN("Could not find matching CV profile DPT for instance "+fullName);
      DebugTN("CVs in instance: " + strjoin(cvNames, ", "));
      if (!continueOnError)
        return false;
    }

    // Create separate CV datapoint
    string cvFullName = fullName + "_CV";
    string cvDpt = "{{typePrefix}}{{class_name}}_CV"+profileId;

    if (profileId != "")
    {

    if (createDps)
    {
      if ({{functionPrefix}}dpTypeExists(cvDpt))
      {
        DebugTN("Will create CalculatedVariable profile DP "+cvFullName+" of type "+cvDpt);
        int result = dpCreate(cvFullName, cvDpt);
        if (result != 0)
        {
          DebugTN("dpCreate for CalculatedVariable profile DP '"+cvFullName+"' failed or already exists");
          if (!continueOnError)
            return false;
        }
      }
      else
      {
        DebugTN("DPT "+cvDpt+" does not exist, cannot create CalculatedVariable profile DP "+cvFullName);
        DebugTN("This may indicate a mismatch in CV profile detection. Expected profile: "+profileId);
        if (!continueOnError)
          return false;
      }
    }

    if (assignAddresses)
    {
      // Configure addresses for each CV in the profile
      for (int i=1; i<=dynlen(cvNames); i++)
      {
        string cvName = cvNames[i];
        string cvDpe = cvFullName+"."+cvName;
        string cvAddress = fullName+"."+cvName;  // Build address from base instance name (without _CV suffix)
        strreplace(cvAddress, "/", ".");

        bool cvActive = {{functionPrefix}}evaluateActive(
          addressActiveControl,
          "{{class_name}}_CV"+profileId,
          cvName,
          cvDpe);

        bool cvSuccess = {{functionPrefix}}addressConfigWrapper(
          cvDpe,
          cvAddress,
          DPATTR_ADDR_MODE_INPUT_SPONT /* mode */,
          connectionSettings,
          cvActive);

        if (!cvSuccess)
        {
          DebugTN("Failed setting address for CalculatedVariable "+cvAddress);
          if (!continueOnError)
            return false;
        }
      }
    }
    } // end if (profileId != "")
  }
  {% endif %}

  dyn_int children;
  {% for ho in designInspector.objectify_has_objects(class_name, "[@instantiateUsing='configuration']") %}
    children = {{functionPrefix}}getChildNodesWithName(docNum, childNode, "{{ho.get('class')}}");
    for (int i=1; i<=dynlen(children); i++)
    {{functionPrefix}}configure{{ho.get('class')}} (docNum, children[i], fullName+"/", createDps, assignAddresses, continueOnError, addressActiveControl, connectionSettings);
  {% endfor %}

  return success;
}

bool {{functionPrefix}}configureFromName{{class_name}} (
  string  name,
  string  prefix,
  bool    createDps,
  bool    assignAddresses,
  bool    continueOnError,
  mapping addressActiveControl,
  mapping connectionSettings)
{
  DebugTN("ConfigureFromName.{{class_name}} called");
  string fullName = prefix+name;
  string dpt = "{{typePrefix}}{{class_name}}";

  if ({{functionPrefix}}dpTypeExists(dpt))
  {

    if (createDps)
    {

      DebugTN("Will create DP "+fullName);
      int result = dpCreate(fullName, dpt);
      if (result != 0)
      {
        DebugTN("dpCreate name='"+fullName+"' dpt='"+dpt+"' not successful or already existing");
        if (!continueOnError)
            throw(makeError("Cacophony", PRIO_SEVERE, ERR_IMPL, 1, "XXX YYY ZZZ"));
      }
    }

    if (assignAddresses)
    {
      string dpe, address;
      dyn_string dsExceptionInfo;
      bool success;
      bool active = false;

      {% for cv in cls.cachevariable %}
        dpe = fullName+".{{cv.get('name')}}";
        address = dpe; // address can be generated from dpe after some mods ...
        strreplace(address, "/", ".");

        active = {{functionPrefix}}evaluateActive(
          addressActiveControl,
          "{{class_name}}",
          "{{cv.get('name')}}",
          dpe);

        success = {{functionPrefix}}addressConfigWrapper(
          dpe,
          address,
          {{cache_variable_address_space_write_to_mode(cv.get('addressSpaceWrite'))}},
        	connectionSettings,
          active);

        if (!success && !continueOnError)
        {
           DebugTN("Failed setting address "+address+"; will terminate now.");
           return false;
        }
      {% endfor %}

      {% for sv in cls.sourcevariable %}
        dpe = fullName+".{{sv.get('name')}}";
        address = dpe; // address can be generated from dpe after some mods ...
        strreplace(address, "/", ".");

        active = {{functionPrefix}}evaluateActive(
          addressActiveControl,
          "{{class_name}}",
          "{{sv.get('name')}}",
          dpe);

        success = {{functionPrefix}}addressConfigWrapper(
          dpe,
          address,
          {{source_variable_address_space_mode_to_mode(sv.get('addressSpaceRead'), sv.get('addressSpaceWrite'))}} /* mode */,
        	connectionSettings,
          active);

        if (!success && !continueOnError)
        {
           DebugTN("Failed setting address "+address+"; will terminate now.");
           return false;
        }
      {% endfor %}

    }
  }

  {% for ho in designInspector.objectify_has_objects(class_name, "[@instantiateUsing='design']")%}
    // Parse design-instantiated children of class {{ho.get('class')}}
    {% for obj in ho.object %}
      bool childSuccess = {{functionPrefix}}configureFromName{{ho.get('class')}}("{{obj.get('name')}}", fullName+"/", createDps, assignAddresses, continueOnError, addressActiveControl, connectionSettings);
      if (!childSuccess && !continueOnError)
      {
        DebugTN("Failed to configure design-instantiated child {{obj.get('name')}} of class {{ho.get('class')}}");
        return false;
      }
    {% endfor %}
  {% endfor %}

  return true;
}

{% endfor %}

dyn_int {{functionPrefix}}getChildNodesWithName (int docNum, int parentNode, string name)
{
    dyn_int result;
    int node = xmlFirstChild(docNum, parentNode);
    while (node >= 0)
    {
        if (xmlNodeName(docNum, node)==name)
            dynAppend(result, node);
        node = xmlNextSibling (docNum, node);
    }
    return result;
}

int {{functionPrefix}}parseConfig (
    string  configFileName,
    bool    createDps,
    bool    assignAddresses,
    bool    continueOnError,
    mapping addressActiveControl = makeMapping(),
    mapping connectionSettings = makeMapping())
/* Create instances */
{

  /* Apply defaults in connectionSettings, when not concretized by the user */
  if (!mappingHasKey(connectionSettings, CONNECTIONSETTING_KEY_DRIVER_NUMBER))
  {
    connectionSettings[CONNECTIONSETTING_KEY_DRIVER_NUMBER] = {{driverNumber}};
  }
  if (!mappingHasKey(connectionSettings, CONNECTIONSETTING_KEY_SERVER_NAME))
  {
    connectionSettings[CONNECTIONSETTING_KEY_SERVER_NAME] = "{{serverName}}";
  }
  if (!mappingHasKey(connectionSettings, CONNECTIONSETTING_KEY_SUBSCRIPTION_NAME))
  {
    connectionSettings[CONNECTIONSETTING_KEY_SUBSCRIPTION_NAME] = "{{subscriptionName}}";
  }

  /* Pre/Suffix the expression with ^$ to enable exact matches and also check if given patterns make sense */
  for (int i=1; i<=mappinglen(addressActiveControl); i++)
  {
    string regexp = mappingGetValue(addressActiveControl, i);
    regexp = "^"+regexp+"$";
    addressActiveControl[mappingGetKey(addressActiveControl, i)] = regexp;
    int regexpResult = regexpIndex(regexp, "thisdoesntmatter");
    if (regexpResult <= -2)
    {
        DebugTN("It seems that the given regular expression is wrong: "+regexp+"    the process will be aborted");
        return -1;
    }
  }

  string errMsg;
  int errLine;
  int errColumn;

  string configFileToLoad = configFileName;

  if (! _UNIX)
  {
    DebugTN("This code was validated only on Linux systems. For Windows, BE-ICS should perform the validation and release the component. See at https://its.cern.ch/jira/browse/OPCUA-1519 for more information.");
    return -1;
  }

  // try to perform entity substitution
  string tempFile = configFileToLoad + ".temp";
  int result = system("xmllint --noent " + configFileToLoad + " > " + tempFile);
  DebugTN("The call to 'xmllint --noent' resulted in: "+result);
  if (result != 0)
  {
    DebugTN("It was impossible to run xmllint to inflate entities. WinCC OA might load this file incorrectly if entity references are used. So we decided it wont be possible. See at https://its.cern.ch/jira/browse/OPCUA-1519 for more information.");
    return -1;
  }
  configFileToLoad = tempFile;

  int docNum = xmlDocumentFromFile(configFileToLoad , errMsg, errLine, errColumn);
  if (docNum < 0)
  {
    DebugN("Didn't open the file: at Line="+errLine+" Column="+errColumn+" Message=" + errMsg);
    return -1;
  }

  int firstNode = xmlFirstChild(docNum);
  if (firstNode < 0)
  {
    DebugN("Cant get the first child of the config file.");
    return -1;
  }

  while (xmlNodeName(docNum, firstNode) != "configuration")
  {
    firstNode = xmlNextSibling(docNum, firstNode);
    if (firstNode < 0)
    {
      DebugTN("configuration node not found, sorry.");
      return -1;
    }
  }

  // now firstNode holds configuration node
  dyn_int children;
  {% set root = designInspector.objectify_root() %}
  {% for ho in root.hasobjects %}
    {% if ho.get('instantiateUsing') == 'configuration' %}
      dyn_int children = {{functionPrefix}}getChildNodesWithName(docNum, firstNode, "{{ho.get('class')}}");
      for (int i = 1; i<=dynlen(children); i++)
      {
        {{functionPrefix}}configure{{ho.get('class')}} (docNum, children[i], "", createDps, assignAddresses, continueOnError, addressActiveControl, connectionSettings);
      }
    {% elif ho.get('instantiateUsing') == 'design' %}
      {{debug("WARNING: Skipping objects instantiated by design. For pure design instantiation ")}}
      {{debug("please run instantiateFromDesign.ctl")}}
      {{debug("  ... previous warning is at Root, hasobjects to class: ", ho.get('class'))}}
    {% else %}
      {{debug("ERROR: unsupported mode.")}}
    {% endif %}
  {% endfor %}


  return 0;
}
